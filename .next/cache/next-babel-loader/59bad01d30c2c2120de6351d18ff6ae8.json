{"ast":null,"code":"import nextConnect from 'next-connect';\nimport isEmail from 'validator/lib/isEmail';\nimport normalizeEmail from 'validator/lib/normalizeEmail';\nimport bcrypt from 'bcryptjs';\nimport middleware from '../../middlewares/middleware';\nimport { extractUser } from '../../lib/api-helpers';\nimport { nanoid } from 'nanoid';\nconst handler = nextConnect();\nconst passKey = nanoid(12);\nhandler.use(middleware); // see how we're reusing our middleware\n// POST /api/users\n\nhandler.post(async (req, res) => {\n  const {\n    name,\n    password\n  } = req.body;\n  const email = normalizeEmail(req.body.email); // this is to handle things like jane.doe@gmail.com and janedoe@gmail.com being the same\n\n  if (!isEmail(email)) {\n    res.status(400).send('The email you entered is invalid.');\n    return;\n  }\n\n  if (!password || !name) {\n    res.status(400).send('Missing field(s)');\n    return;\n  } // check if email existed\n\n\n  if ((await req.db.collection('users').countDocuments({\n    email\n  })) > 0) {\n    res.status(403).send('The email has already been used.');\n  }\n\n  const hashedPassword = await bcrypt.hash(password, 10);\n  const user = await req.db.collection('users').insertOne({\n    email,\n    password: hashedPassword,\n    name,\n    passKey\n  }).then(({\n    ops\n  }) => ops[0]);\n  req.logIn(user, err => {\n    if (err) throw err; // when we finally log in, return the (filtered) user object\n\n    res.status(201).json({\n      user: extractUser(req)\n    });\n  });\n});\nexport default handler;","map":{"version":3,"sources":["/Users/kevin/Desktop/Next.js-Mongodb-Authentication-App/pages/api/users.js"],"names":["nextConnect","isEmail","normalizeEmail","bcrypt","middleware","extractUser","nanoid","handler","passKey","use","post","req","res","name","password","body","email","status","send","db","collection","countDocuments","hashedPassword","hash","user","insertOne","then","ops","logIn","err","json"],"mappings":"AAAA,OAAOA,WAAP,MAAwB,cAAxB;AACA,OAAOC,OAAP,MAAoB,uBAApB;AACA,OAAOC,cAAP,MAA2B,8BAA3B;AACA,OAAOC,MAAP,MAAmB,UAAnB;AACA,OAAOC,UAAP,MAAuB,8BAAvB;AACA,SAASC,WAAT,QAA4B,uBAA5B;AACA,SAASC,MAAT,QAAuB,QAAvB;AAEA,MAAMC,OAAO,GAAGP,WAAW,EAA3B;AACA,MAAMQ,OAAO,GAAGF,MAAM,CAAC,EAAD,CAAtB;AAEAC,OAAO,CAACE,GAAR,CAAYL,UAAZ,E,CAAyB;AAEzB;;AACAG,OAAO,CAACG,IAAR,CAAa,OAAOC,GAAP,EAAYC,GAAZ,KAAoB;AAC/B,QAAM;AAAEC,IAAAA,IAAF;AAAQC,IAAAA;AAAR,MAAqBH,GAAG,CAACI,IAA/B;AACA,QAAMC,KAAK,GAAGd,cAAc,CAACS,GAAG,CAACI,IAAJ,CAASC,KAAV,CAA5B,CAF+B,CAEe;;AAC9C,MAAI,CAACf,OAAO,CAACe,KAAD,CAAZ,EAAqB;AACnBJ,IAAAA,GAAG,CAACK,MAAJ,CAAW,GAAX,EAAgBC,IAAhB,CAAqB,mCAArB;AACA;AACD;;AACD,MAAI,CAACJ,QAAD,IAAa,CAACD,IAAlB,EAAwB;AACtBD,IAAAA,GAAG,CAACK,MAAJ,CAAW,GAAX,EAAgBC,IAAhB,CAAqB,kBAArB;AACA;AACD,GAV8B,CAW/B;;;AACA,MAAI,CAAC,MAAMP,GAAG,CAACQ,EAAJ,CAAOC,UAAP,CAAkB,OAAlB,EAA2BC,cAA3B,CAA0C;AAAEL,IAAAA;AAAF,GAA1C,CAAP,IAA+D,CAAnE,EAAsE;AACpEJ,IAAAA,GAAG,CAACK,MAAJ,CAAW,GAAX,EAAgBC,IAAhB,CAAqB,kCAArB;AACD;;AACD,QAAMI,cAAc,GAAG,MAAMnB,MAAM,CAACoB,IAAP,CAAYT,QAAZ,EAAsB,EAAtB,CAA7B;AACA,QAAMU,IAAI,GAAG,MAAMb,GAAG,CAACQ,EAAJ,CAChBC,UADgB,CACL,OADK,EAEhBK,SAFgB,CAEN;AAAET,IAAAA,KAAF;AAASF,IAAAA,QAAQ,EAAEQ,cAAnB;AAAmCT,IAAAA,IAAnC;AAAyCL,IAAAA;AAAzC,GAFM,EAGhBkB,IAHgB,CAGX,CAAC;AAAEC,IAAAA;AAAF,GAAD,KAAaA,GAAG,CAAC,CAAD,CAHL,CAAnB;AAIAhB,EAAAA,GAAG,CAACiB,KAAJ,CAAUJ,IAAV,EAAiBK,GAAD,IAAS;AACvB,QAAIA,GAAJ,EAAS,MAAMA,GAAN,CADc,CAEvB;;AACAjB,IAAAA,GAAG,CAACK,MAAJ,CAAW,GAAX,EAAgBa,IAAhB,CAAqB;AACnBN,MAAAA,IAAI,EAAEnB,WAAW,CAACM,GAAD;AADE,KAArB;AAGD,GAND;AAOD,CA3BD;AA6BA,eAAeJ,OAAf","sourcesContent":["import nextConnect from 'next-connect';\nimport isEmail from 'validator/lib/isEmail';\nimport normalizeEmail from 'validator/lib/normalizeEmail';\nimport bcrypt from 'bcryptjs';\nimport middleware from '../../middlewares/middleware';\nimport { extractUser } from '../../lib/api-helpers';\nimport { nanoid } from 'nanoid'\n\nconst handler = nextConnect();\nconst passKey = nanoid(12);\n\nhandler.use(middleware); // see how we're reusing our middleware\n\n// POST /api/users\nhandler.post(async (req, res) => {\n  const { name, password } = req.body;\n  const email = normalizeEmail(req.body.email); // this is to handle things like jane.doe@gmail.com and janedoe@gmail.com being the same\n  if (!isEmail(email)) {\n    res.status(400).send('The email you entered is invalid.');\n    return;\n  }\n  if (!password || !name) {\n    res.status(400).send('Missing field(s)');\n    return;\n  }\n  // check if email existed\n  if ((await req.db.collection('users').countDocuments({ email })) > 0) {\n    res.status(403).send('The email has already been used.');\n  }\n  const hashedPassword = await bcrypt.hash(password, 10);\n  const user = await req.db\n    .collection('users')\n    .insertOne({ email, password: hashedPassword, name, passKey })\n    .then(({ ops }) => ops[0]);\n  req.logIn(user, (err) => {\n    if (err) throw err;\n    // when we finally log in, return the (filtered) user object\n    res.status(201).json({\n      user: extractUser(req),\n    });\n  });\n});\n\nexport default handler;"]},"metadata":{},"sourceType":"module"}